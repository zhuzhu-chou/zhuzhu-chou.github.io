(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{285:function(t,_,s){"use strict";s.r(_);var v=s(0),n=Object(v.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("div",{staticClass:"content"},[s("p",[s("strong",[t._v("四次挥手")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/%E5%9B%9B%E6%8C%A5.png",alt:""}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/%E5%9B%9B%E6%AC%A1.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("四次挥手的原因")])]),t._v(" "),s("p",[t._v("这由TCP的"),s("strong",[t._v("半关闭")]),t._v("（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。关闭连接时，当服务端收到FIN报文时，很可能"),s("strong",[t._v("并不会立即关闭SOCKET")]),t._v('，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。')]),t._v(" "),s("p",[s("strong",[t._v("2MSL等待状态")])]),t._v(" "),s("p",[t._v("每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在"),s("strong",[t._v("网络内传输")]),t._v("，而IP数据报则有限制其生存时间的TTL字段。")]),t._v(" "),s("p",[t._v("对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。")]),t._v(" "),s("p",[s("strong",[t._v("TIME-WAIT 状态等待 2MSL 的意义")])]),t._v(" "),s("ul",[s("li",[t._v("为了保证第四次挥手时客户端发送的ACK报文段能到达服务端。这这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 服务端 收不到对已发送的 FIN + ACK 报文段的确认。服务端 会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务端都正常进入到 CLOSED 状态。如果客户端在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 服务端 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，服务端 就无法按照正常步骤进入 CLOSED 状态。")]),t._v(" "),s("li",[t._v("防止"),s("strong",[t._v("已失效的连接请求报文段")]),t._v("出现在本连接中。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。")])])])}],!1,null,null,null);_.default=n.exports}}]);