(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{288:function(_,v,t){"use strict";t.r(v);var s=t(0),a=Object(s.a)({},(function(){var _=this.$createElement;this._self._c;return this._m(0)}),[function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("div",{staticClass:"content"},[t("p",[_._v("相关状态")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/%E7%8A%B6%E6%80%81.png",alt:""}})]),_._v(" "),t("h2",{attrs:{id:"三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/%E4%B8%89%E6%8F%A11.png",alt:""}})]),_._v(" "),t("blockquote",[t("p",[_._v("进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。")])]),_._v(" "),t("h3",{attrs:{id:"为什么要三次握手，两次握手不行吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要三次握手，两次握手不行吗"}},[_._v("#")]),_._v(" 为什么要三次握手，两次握手不行吗")]),_._v(" "),t("p",[_._v("试想如果是用两次握手，则会出现下面这种情况：")]),_._v(" "),t("div",{staticClass:"danger custom-block"},[t("p",{staticClass:"custom-block-title"},[_._v("WARNING")]),_._v(" "),t("p",[_._v("如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在"),t("strong",[_._v("某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端")]),_._v("，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。")]),_._v(" "),t("p",[_._v("使用三次握手，客户端就会忽略服务端对丢失报文的确认。")])]),_._v(" "),t("h3",{attrs:{id:"什么是半连接队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是半连接队列"}},[_._v("#")]),_._v(" 什么是半连接队列")]),_._v(" "),t("p",[_._v("服务器第一次收到客户端的 SYN 之后，就会处于 "),t("code",[_._v("SYN_RCVD")]),_._v(" 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个"),t("strong",[_._v("队列")]),_._v("里，我们把这种队列称之为"),t("strong",[_._v("半连接队列")]),_._v("。")]),_._v(" "),t("p",[_._v("当然还有一个"),t("strong",[_._v("全连接队列")]),_._v("，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。")]),_._v(" "),t("p",[_._v("这里在补充一点关于"),t("strong",[_._v("SYN-ACK 重传次数")]),_._v("的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......")]),_._v(" "),t("h3",{attrs:{id:"三次握手过程中可以携带数据吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手过程中可以携带数据吗"}},[_._v("#")]),_._v(" 三次握手过程中可以携带数据吗")]),_._v(" "),t("p",[_._v("其实第三次握手的时候，是可以携带数据的。但是，"),t("strong",[_._v("第一次、第二次握手不可以携带数据")])]),_._v(" "),t("p",[_._v("为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。")]),_._v(" "),t("p",[_._v("也就是说，第一次握手不可以放数据，其中一个简单的原因就是会"),t("strong",[_._v("让服务器更加容易受到攻击了")]),_._v("。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。")]),_._v(" "),t("h2",{attrs:{id:"syn-flood攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#syn-flood攻击"}},[_._v("#")]),_._v(" SYN Flood攻击")]),_._v(" "),t("p",[t("strong",[_._v("攻击原理")])]),_._v(" "),t("p",[_._v("SYN 攻击是一种典型的 "),t("strong",[_._v("DoS/DDoS 攻击")]),_._v("。其攻击的原理很简单，就是用客户端在短时间内"),t("strong",[_._v("伪造大量不存在的 IP 地址")]),_._v("，并向服务端疯狂发送"),t("code",[_._v("SYN")]),_._v("。对于服务端（服务端更容易受到"),t("strong",[_._v("SYN攻击")]),_._v("）而言，会产生两个危险的后果:")]),_._v(" "),t("ul",[t("li",[_._v("处理大量的"),t("code",[_._v("SYN")]),_._v("包并返回对应"),t("code",[_._v("ACK")]),_._v(", 势必有大量连接处于"),t("code",[_._v("SYN_RCVD")]),_._v("状态，从而占满整个"),t("strong",[_._v("半连接队列")]),_._v("，无法处理正常的请求。")]),_._v(" "),t("li",[_._v("由于是不存在的 IP，服务端长时间收不到客户端的"),t("code",[_._v("ACK")]),_._v("，会导致服务端不断重发数据，直到"),t("strong",[_._v("耗尽服务端的资源。")])])]),_._v(" "),t("p",[_._v("检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。")]),_._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("netstat -n -p TCP | grep SYN_RECV\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br")])]),t("p",[_._v("常见的防御 SYN 攻击的方法有如下几种：")]),_._v(" "),t("ul",[t("li",[_._v("增加 SYN 连接，也就是增加半连接队列的容量。")]),_._v(" "),t("li",[_._v("减少 SYN + ACK 重试次数，避免大量的超时重发。")]),_._v(" "),t("li",[_._v("利用 SYN Cookie 技术，在服务端接收到"),t("code",[_._v("SYN")]),_._v("后不立即分配连接资源，而是根据这个"),t("code",[_._v("SYN")]),_._v("计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复"),t("code",[_._v("ACK")]),_._v("的时候带上这个"),t("code",[_._v("Cookie")]),_._v("值，服务端验证 Cookie 合法之后才分配连接资源。")])])])}],!1,null,null,null);v.default=a.exports}}]);