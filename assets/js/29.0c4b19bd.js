(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{241:function(t,e,_){"use strict";_.r(e);var s=_(0),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),_("p",[t._v("服务器唯一保存着密钥，传给客户端的数字证书包含了公钥。公钥加密，私钥解密，可知 RSA 采用非对称加密。")]),t._v(" "),_("p",[_("a",{attrs:{href:"http://47.98.159.95/my_blog/week12/1.jpg",target:"_blank",rel:"noopener noreferrer"}},[_("img",{attrs:{src:"http://47.98.159.95/my_blog/week12/1.jpg",alt:"project"}}),_("OutboundLink")],1)]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),_("p",[t._v("TLS 1.2 版本的加解密流程：")]),t._v(" "),_("p",[_("a",{attrs:{href:"http://47.98.159.95/my_blog/http/010.jpg",target:"_blank",rel:"noopener noreferrer"}},[_("img",{attrs:{src:"http://47.98.159.95/my_blog/http/010.jpg",alt:"img"}}),_("OutboundLink")],1)]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),_("p",[t._v("RSA 握手过程中，服务器私钥泄露后，并且中间人截获之前所有报文的时候，就能拿到 client_random、server_random 和 pre_random 并且使用对应的随机数函数生成 secret，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式破解。")]),t._v(" "),_("p",[t._v("而 ECDHE 在每次握手时都会生成临时的密钥对，即使私钥破解，之前的历史记录也不受影响，这种一次破解不影响历史信息的性质叫前向安全性。")]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),_("p",[t._v("流程如下: "),_("a",{attrs:{href:"http://47.98.159.95/my_blog/http/011.jpg",target:"_blank",rel:"noopener noreferrer"}},[_("img",{attrs:{src:"http://47.98.159.95/my_blog/http/011.jpg",alt:"img"}}),_("OutboundLink")],1)]),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),_("p",[t._v("::; tip")]),t._v(" "),_("p",[t._v("1-RTT 优化到 0-RTT")]),t._v(" "),_("p",[t._v(":::")]),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25)])}),[function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("对称加密和非对称加密")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("strong",[this._v("对称加密")]),this._v("：最简单的方式，指的是加密和解密用的是同样的密钥。")]),this._v(" "),e("li",[e("strong",[this._v("非对称加密")]),this._v("：如果有 A、B 两把密钥，用 A 加密过的数据包只能用 B 解密，反之，B 加密过必须用 A 解密。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"传统-rsa-版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#传统-rsa-版本"}},[this._v("#")]),this._v(" 传统 RSA 版本")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果传输过程遇到 "),e("strong",[this._v("DNS 劫持")]),this._v("，将目标地址替换为劫持黑客的服务器，然后黑客自己造一份公钥和私钥，照样可以进行数据传输。HTTPS 在上述对称加密和非对称加密基础上，又添加了数字证书认证的步骤。目的是让服务器证明自己的身份。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"tls-1-2-握手过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tls-1-2-握手过程"}},[this._v("#")]),this._v(" "),e("code",[this._v("TLS/1.2")]),this._v(" 握手过程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("上诉加解密之所以成为 RSA 版本，是因为解密 "),e("code",[this._v("pre_random")]),this._v("  的时候采用了 "),e("strong",[e("code",[this._v("RSA 算法")])])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("strong",[t._v("Step 1")]),t._v("："),_("strong",[t._v("Client Hello")])]),t._v(" "),_("p",[_("code",[t._v("client_random")]),t._v(" 为后面生成最终 "),_("code",[t._v("secrect")]),t._v(" 的一个参数。")]),t._v(" "),_("p",[t._v("加密套件一般长这样：")]),t._v(" "),_("div",{staticClass:"language-http line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-http"}},[_("code",[t._v("TLS_ECDHE_WITH_AES_128_GCM_SHA256\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("意思是"),_("code",[t._v("TLS")]),t._v("握手过程中，使用"),_("code",[t._v("ECDHE")]),t._v("算法生成"),_("code",[t._v("pre_random")]),t._v("(这个数后面会介绍)，128位的"),_("code",[t._v("AES")]),t._v("算法进行对称加密，在对称加密的过程中使用主流的"),_("code",[t._v("GCM")]),t._v("分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是"),_("strong",[t._v("哈希摘要算法")]),t._v("，采用"),_("code",[t._v("SHA256")]),t._v("算法。")]),t._v(" "),_("blockquote",[_("p",[t._v("哈希摘要算法：在 TLS 握手过程中用于将服务端的证书信息生成一个摘要（可以理解为"),_("strong",[t._v("比较短的字符串")]),t._v("），用来表识这个服务器的身份，然后把加密后的标识和公钥传给客户端，客户端会用公钥解密，生成另外一份摘要。两个摘要进行对比，相同则认证成功。其中除了用到了哈希算法，最重要的过程是私钥加密，然后服务端用传来的公钥解密。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("Step 2")]),t._v("："),_("strong",[t._v("Server Hello")])]),t._v(" "),_("p",[_("code",[t._v("server_random")]),t._v(" 也是最后生成 "),_("code",[t._v("secrect")]),t._v(" 的一个参数。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("Step3：Client 验证证书，生成 secret")])]),t._v(" "),_("p",[t._v("基于 "),_("strong",[_("code",[t._v("ECDHE 算法（对称加密算法")])]),t._v("）计算出 "),_("code",[t._v("pre_random")]),t._v("。")]),t._v(" "),_("p",[t._v("客户端现在拥有了"),_("code",[t._v("client_random")]),t._v("、"),_("code",[t._v("server_random")]),t._v("和"),_("code",[t._v("pre_random")]),t._v("，接下来将这三个数通过一个伪随机数函数来计算出最终的"),_("code",[t._v("secret")]),t._v("。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("Step4：Server 生成 secrect")])]),t._v(" "),_("p",[t._v("注意客户端是先生成 "),_("strong",[_("code",[t._v("client_params")])]),t._v(" ，再用 "),_("strong",[_("code",[t._v("ECDHE 算法")]),_("strong",[t._v("生成 "),_("code",[t._v("pre_random")]),t._v("。客户端生成 "),_("code",[t._v("client_params")]),t._v(" 之后就传给服务器，服务器同样采用 "),_("strong",[_("code",[t._v("ECDHE 算法")])]),t._v("，生成 pre_random，之后服务端也拥有了 client_random、server_random和 pre_random，采用和客户端一样的")]),t._v("伪随机函数")]),t._v("生成 "),_("code",[t._v("secrect")]),t._v("。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("RSA 和 ECDHE 握手过程的区别")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("TLS1.2 握手中，使用"),_("code",[t._v("ECDHE")]),t._v("实现"),_("code",[t._v("pre_random")]),t._v("的加密解密，没有用到 RSA。")]),t._v(" "),_("li",[t._v("使用 ECDHE 还有一个特点，就是客户端发送完收尾消息后可以提前"),_("code",[t._v("抢跑")]),t._v("，直接发送 HTTP 报文，节省了一个 "),_("strong",[_("code",[t._v("RTT（往返时延")])]),t._v("），不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫"),_("code",[t._v("TLS False Start")]),t._v("。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"tls-1-3-握手过程的改进"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tls-1-3-握手过程的改进"}},[this._v("#")]),this._v(" "),e("code",[this._v("TLS 1.3")]),this._v(" 握手过程的改进")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"强化安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强化安全"}},[this._v("#")]),this._v(" 强化安全")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("RSA算法不具备"),e("strong",[this._v("前向安全性")]),this._v("，而E CDHE 具备，因此在 TLS1.3 中彻底取代了 RSA")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("解释一下什么是前向安全性")]),this._v("：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"提升性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提升性能"}},[this._v("#")]),this._v(" 提升性能")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("和 TLS 1.2 相比少了一个 RTT")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("TLS 1.3 握手方式也被叫做"),e("strong",[this._v("1-RTT握手")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("服务端不必等待对方验证证书之后才拿到"),e("code",[this._v("client_params")]),this._v("，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算"),e("code",[this._v("secret")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"会话复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#会话复用"}},[this._v("#")]),this._v(" 会话复用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("会话复用有两种方式: "),e("strong",[this._v("Session ID")]),this._v("和"),e("strong",[this._v("Session Ticket")]),this._v("。")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("最早出现的 "),_("strong",[_("code",[t._v("Session ID")])]),t._v("：客户端和服务端首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送 ID 过来，服务端查找这个 ID 是否存在，找到了就复用之前的会话状态，会话密钥就不用重新生成了，直接用原来那份。")])]),t._v(" "),_("li",[_("p",[t._v("但 Session ID 有个弊端：当客户端数量庞大时，服务器存储压力会很大。")]),t._v(" "),_("p",[t._v("因此出现 "),_("strong",[_("code",[t._v("Session Ticket")])]),t._v("。**思路是：既然服务端压力大，就分摊到客户端。**具体来说，")]),t._v(" "),_("p",[t._v("首次连接之后，服务器将通过 "),_("strong",[_("code",[t._v("ticket key")])]),t._v(" 密钥将会话状态加密生成一个 ticket，然后发送给客户端，再次连接时，客户端发送 ticket 给服务端，用 ticket key 解密，验证过期时间，拿出里面的"),_("strong",[t._v("会话状态（包括会话密钥）")]),t._v("。")]),t._v(" "),_("p",[t._v("提高了性能，但是带来了安全问题。为了保证前向安全性，需要对这个 ticket key 进行轮转变化，不过重点是在轮转的过程中需要兼容老的 ticket key，用新的 ticket key 进行加解密，用老的 ticket key 只进行解密，最终慢慢淘汰掉老的 ticket key。从而安全的复用效果。")]),t._v(" "),_("blockquote",[_("p",[t._v("目前有较多的方法来轮转这个ticket key。我们公司目前采用的是 cloudflare 公司开源出来的轮转方式，每小时轮转一次。")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"psk"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#psk"}},[this._v("#")]),this._v(" PSK")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("刚刚说的都是"),e("code",[this._v("1-RTT")]),this._v("情况下的优化，那能不能优化到"),e("code",[this._v("0-RTT")]),this._v("呢？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("答案是可以的。做法其实也很简单，在发送"),e("strong",[this._v("Session Ticket")]),this._v("的同时带上应用数据，不用等到服务端确认，这种方式被称为"),e("code",[this._v("Pre-Shared Key")]),this._v("，即 "),e("strong",[e("code",[this._v("PSK")])]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这种方式虽然方便，但也带来了安全问题。中间人截获"),e("code",[this._v("PSK")]),this._v("的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，增加了服务器被攻击的风险。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"https-和-http-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https-和-http-的区别"}},[this._v("#")]),this._v(" "),e("code",[this._v("HTTPS")]),this._v(" 和 "),e("code",[this._v("HTTP")]),this._v(" 的区别")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("Https协议需要ca证书，费用较高。")]),this._v(" "),e("li",[this._v("http是超文本传输协议，信息是明文传输，https则是加密传输协议。")]),this._v(" "),e("li",[this._v("http协议的默认端口为80，https的端口为443")]),this._v(" "),e("li",[this._v("http的连接很简单，是无状态的；HTTPS协议是由TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。")])])}],!1,null,null,null);e.default=r.exports}}]);