(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{286:function(e,n,r){"use strict";r.r(n);var s=r(0),a=Object(s.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"content"},[r("p",[e._v("回调函数时代\n相信很多 nodejs 的初学者都或多或少踩过这样的坑，node 中很多原生的 api 就是诸如这样的:")]),e._v(" "),r("p",[e._v("fs.readFile('xxx', (err, data) => {")]),e._v(" "),r("p",[e._v("});\n典型的高阶函数，将回调函数作为函数参数传给了readFile。但久而久之，就会发现，这种传入回调的方式也存在大坑, 比如下面这样:")]),e._v(" "),r("p",[e._v("fs.readFile('1.json', (err, data) => {\nfs.readFile('2.json', (err, data) => {\nfs.readFile('3.json', (err, data) => {\nfs.readFile('4.json', (err, data) => {")]),e._v(" "),r("pre",[r("code",[e._v("        });\n    });\n});\n")])]),e._v(" "),r("p",[e._v("});\n回调当中嵌套回调，也称回调地狱。这种代码的可读性和可维护性都是非常差的，因为嵌套的层级太多。而且还有一个严重的问题，就是每次任务可能会失败，需要在回调里面对每个任务的失败情况进行处理，增加了代码的混乱程度。")]),e._v(" "),r("p",[e._v("#Promise 时代\nES6 中新增的 Promise 就很好了解决了回调地狱的问题，同时了合并了错误处理。写出来的代码类似于下面这样:")]),e._v(" "),r("p",[e._v("readFilePromise('1.json').then(data => {\nreturn readFilePromise('2.json')\n}).then(data => {\nreturn readFilePromise('3.json')\n}).then(data => {\nreturn readFilePromise('4.json')\n});\n以链式调用的方式避免了大量的嵌套，也符合人的线性思维方式，大大方便了异步编程。")]),e._v(" "),r("p",[e._v("#co + Generator 方式\n利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。")]),e._v(" "),r("p",[e._v("co(function* () {\nconst r1 = yield readFilePromise('1.json');\nconst r2 = yield readFilePromise('2.json');\nconst r3 = yield readFilePromise('3.json');\nconst r4 = yield readFilePromise('4.json');\n})\n#async + await方式\n这是 ES7 中新增的关键字，凡是加上 async 的函数都默认返回一个 Promise 对象，而更重要的是 async + await 也能让异步代码以同步的方式来书写，而不需要借助第三方库的支持。")]),e._v(" "),r("p",[e._v("const readFileAsync = async function () {\nconst f1 = await readFilePromise('1.json')\nconst f2 = await readFilePromise('2.json')\nconst f3 = await readFilePromise('3.json')\nconst f4 = await readFilePromise('4.json')\n}\n这四种经典的异步编程方式就简单回顾完了，由于是鸟瞰大局，我觉得知道是什么比了解细节要重要, 因此也没有展开。不过没关系，接下来，让我们针对这些具体的解决方案，一步步深入异步编程，理解其中的本质。")])])}],!1,null,null,null);n.default=a.exports}}]);