(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{237:function(t,a,s){"use strict";s.r(a);var e=s(0),_=Object(e.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h2",{attrs:{id:"什么是-http-队头阻塞？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-http-队头阻塞？"}},[t._v("#")]),t._v(" 什么是 HTTP 队头阻塞？")]),t._v(" "),s("p",[t._v("从前面的小节可以知道，HTTP 传输是基于"),s("code",[t._v("请求-应答")]),t._v("的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的"),s("code",[t._v("HTTP队头阻塞")]),t._v("问题。")]),t._v(" "),s("h2",{attrs:{id:"并发连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发连接"}},[t._v("#")]),t._v(" 并发连接")]),t._v(" "),s("p",[t._v("对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。")]),t._v(" "),s("p",[t._v("但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。")]),t._v(" "),s("h2",{attrs:{id:"域名分片"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#域名分片"}},[t._v("#")]),t._v(" 域名分片")]),t._v(" "),s("p",[t._v("一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。")]),t._v(" "),s("p",[t._v("比如 content1.sanyuan.com 、content2.sanyuan.com。")]),t._v(" "),s("p",[t._v("这样一个"),s("code",[t._v("sanyuan.com")]),t._v("域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。")]),t._v(" "),s("h2",{attrs:{id:"多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),s("p",[t._v("HTTP/2 多路复用就是为了解决队头阻塞的问题。")])])}],!1,null,null,null);a.default=_.exports}}]);