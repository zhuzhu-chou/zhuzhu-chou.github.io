(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{238:function(_,v,t){"use strict";t.r(v);var s=t(0),a=Object(s.a)({},(function(){var _=this.$createElement;this._self._c;return this._m(0)}),[function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("div",{staticClass:"content"},[t("p",[_._v("由于 HTTPS 在安全方面已经做的非常好了，HTTP 改进的关注点放在了性能方面。对于 HTTP/2 而言，它对于性能的提升主要在于两点:")]),_._v(" "),t("ul",[t("li",[_._v("头部压缩")]),_._v(" "),t("li",[_._v("多路复用")])]),_._v(" "),t("p",[_._v("当然还有一些颠覆性的功能实现:")]),_._v(" "),t("ul",[t("li",[_._v("设置请求优先级")]),_._v(" "),t("li",[_._v("服务器推送")])]),_._v(" "),t("p",[_._v("这些重大的提升本质上也是为了解决 HTTP 本身的问题而产生的。接下来我们来看看 HTTP/2 解决了哪些问题，以及解决方式具体是如何的。")]),_._v(" "),t("p",[t("strong",[_._v("先理解 HTTP/2 中两个特别重要的概念")])]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("帧（frame）")])]),_._v(" "),t("p",[t("strong",[_._v("HTTP/2.0 通信的最小单位")]),_._v("，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("流（stream）")])]),_._v(" "),t("p",[_._v("流是一个独立的，双向的帧序列可以通过一个 http2 的连接在服务端与客户端之间不断的交换数据")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("消息")]),_._v("：指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。")])])]),_._v(" "),t("h2",{attrs:{id:"头部压缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[_._v("#")]),_._v(" 头部压缩")]),_._v(" "),t("p",[t("code",[_._v("HTTP/1.1")]),_._v(" 通过 "),t("code",[_._v("Content-Encoding")]),_._v(" 指定"),t("strong",[_._v("请求体")]),_._v("的压缩编码方式，但没有字段可以控制"),t("strong",[_._v("请求头")]),_._v("的压缩。当请求字段非常复杂的时候，比如 GET ，报文基本上全是请求头，还有很大的优化空间，HTTP/2 针对头部字段，采用了 "),t("strong",[t("code",[_._v("HPACK 压缩算法")])]),_._v("，对请求头进行压缩。")]),_._v(" "),t("p",[_._v("**"),t("code",[_._v("HPACK 算法")]),_._v("**的原理和亮点")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("对于请求字段的精简和复用")]),_._v("。首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要将索引（如0,1,2,3,...）传给对方，对方根据索引查表。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/HAPACK.png",alt:""}})]),_._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",{staticClass:"custom-block-title"},[_._v("提示")]),_._v(" "),t("p",[_._v('表中出现的带冒号的头部字段解释：HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个":"前缀，用来和其它请求头区分开。')])])]),_._v(" "),t("li",[t("p",[_._v("其次是对于整数和字符串进行"),t("strong",[_._v("哈弗曼编码")]),_._v("，哈弗曼的原理：先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，提高"),t("strong",[_._v("压缩率")]),_._v("。")])])]),_._v(" "),t("h2",{attrs:{id:"多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[_._v("#")]),_._v(" 多路复用")]),_._v(" "),t("h3",{attrs:{id:"http-队头阻塞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-队头阻塞"}},[_._v("#")]),_._v(" HTTP 队头阻塞")]),_._v(" "),t("p",[_._v("我们之前讨论了 HTTP 队头阻塞的问题，其根本原因在于HTTP 基于"),t("code",[_._v("请求-响应")]),_._v("的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。")]),_._v(" "),t("p",[_._v("后面我们又讨论到用"),t("strong",[_._v("并发连接")]),_._v("和"),t("strong",[_._v("域名分片")]),_._v("的方式来解决这个问题，但这并没有真正从 HTTP 本身的层面解决问题，只是增加了 TCP 连接，分摊风险而已。而且这么做也有弊端，多条 TCP 连接会竞争"),t("strong",[_._v("有限的带宽")]),_._v("，让真正优先级高的请求不能优先处理。")]),_._v(" "),t("p",[_._v("而 HTTP/2 便从 HTTP 协议本身解决了"),t("code",[_._v("队头阻塞")]),_._v("问题。注意，这里并不是指的"),t("code",[_._v("TCP队头阻塞")]),_._v("，而是"),t("code",[_._v("HTTP队头阻塞")]),_._v("，两者并不是一回事。TCP 的队头阻塞是在"),t("code",[_._v("数据包")]),_._v("层面，单位是"),t("code",[_._v("数据包")]),_._v("，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而HTTP 的队头阻塞是在 "),t("code",[_._v("HTTP 请求-响应")]),_._v("层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。")]),_._v(" "),t("p",[_._v("那么 HTTP/2 如何来解决所谓的队头阻塞呢？")]),_._v(" "),t("h3",{attrs:{id:"二进制分帧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二进制分帧"}},[_._v("#")]),_._v(" 二进制分帧")]),_._v(" "),t("p",[_._v("原来"),t("code",[_._v("Headers + Body")]),_._v("的报文格式如今被拆分成了一个个二进制的帧，用"),t("strong",[_._v("Headers帧")]),_._v("存放头部字段，"),t("strong",[_._v("Data帧")]),_._v("存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpg",alt:""}})]),_._v(" "),t("h2",{attrs:{id:"服务器推送"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务器推送"}},[_._v("#")]),_._v(" 服务器推送")]),_._v(" "),t("p",[_._v("在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 "),t("strong",[t("code",[_._v("stream")])]),_._v(" 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。")]),_._v(" "),t("h2",{attrs:{id:"流量控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[_._v("#")]),_._v(" 流量控制")]),_._v(" "),t("p",[_._v("HTTP/2 使得"),t("strong",[_._v("客户端")]),_._v("和"),t("strong",[_._v("服务端")]),_._v("都具备"),t("strong",[_._v("调整传输速度")]),_._v("的能力，用 "),t("strong",[t("code",[_._v("WINDOW_UPDATE")]),_._v("帧")]),_._v(" 来指示流量控制信息。每个帧告诉对方，发送方想要接受多少字节。当一端接收并处理被发送的数据时，它也会发出一个**"),t("code",[_._v("WINDOW_UPDATE")]),_._v("帧**来更新数据接收窗口。")]),_._v(" "),t("h2",{attrs:{id:"优先级设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先级设置"}},[_._v("#")]),_._v(" 优先级设置")]),_._v(" "),t("p",[_._v("将 HTTP 消息分解为很多独立的帧之后，我们就可以复用多个数据流中的帧，客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素。为了做到这一点，HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("可以向每个数据流分配一个介于 1 至 256 之间的整数。")])]),_._v(" "),t("li",[t("p",[_._v("每个数据流与其他数据流之间可以存在显式依赖关系。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/%E4%BC%98%E5%85%88%E7%BA%A7.jpg",alt:""}})])])]),_._v(" "),t("p",[_._v("HTTP/2 内的数据流依赖关系通过将另一个数据流的唯一标识符作为父项引用进行声明；如果忽略标识符，相应数据流将依赖于“根数据流”。声明数据流依赖关系指出，应尽可能先向父数据流分配资源，然后再向其依赖项分配资源。换句话说，“请先处理和传输响应 D，然后再处理和传输响应 C”。")]),_._v(" "),t("p",[_._v("共享相同父项的数据流（即，同级数据流）应按其权重比例分配资源。 例如，如果数据流 A 的权重为 12，其同级数据流 B 的权重为 4，那么要确定每个数据流应接收的资源比例，请执行以下操作：\n将所有权重求和：4 + 12 = 16\n将每个数据流权重除以总权重：A = 12/16, B = 4/16因此，数据流 A 应获得四分之三的可用资源，数据流 B 应获得四分之一的可用资源；数据流 B 获得的资源是数据流 A 所获资源的三分之一。")])])}],!1,null,null,null);v.default=a.exports}}]);