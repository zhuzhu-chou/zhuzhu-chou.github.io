(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{252:function(e,n,t){"use strict";t.r(n);var _=t(0),v=Object(_.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("p",[e._v("在执行一段代码时，JS 引擎会首先创建一个执行栈。")]),e._v(" "),t("p",[e._v("然后 JS 引擎会创建一个全局执行上下文，并 push 到执行栈中, 这个过程 JS 引擎会为这段代码中所有变量分配内存并赋一个初始值（undefined），在创建完成后，JS 引擎会进入执行阶段，这个过程 JS 引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值 (真实值)。")]),e._v(" "),t("p",[e._v("如果这段代码中存在 function 的声明和调用，那么 JS 引擎会创建一个函数执行上下文，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文 push 到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。")]),e._v(" "),t("p",[e._v("还有一种特殊情况是，在子函数执行的过程中，父函数已经 "),t("code",[e._v("return")]),e._v(" 了，这种情况下，JS 引擎会将父函数的上下文从执行栈中移除，与此同时，JS 引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。")]),e._v(" "),t("p",[e._v("最后，"),t("code",[e._v("JS")]),e._v(" 引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时 JS 是如何执行的。比如"),t("code",[e._v("setTimeout")]),e._v(" 或 "),t("code",[e._v("fetch")]),e._v(" 请求都是 "),t("code",[e._v("non-blocking")]),e._v(" 的，当异步调用代码触发时，JS 引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS 引擎会立即将与之对应的回调函数 push 进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS 引擎会立刻将任务队列中的回调函数逐个 push 进调用栈并执行。这个过程我们也称之为"),t("strong",[e._v("事件循环")]),e._v("。")])])}],!1,null,null,null);n.default=v.exports}}]);