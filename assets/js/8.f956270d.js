(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{210:function(v,_,t){"use strict";t.r(_);var e=t(0),s=Object(e.a)({},(function(){var v=this.$createElement;this._self._c;return this._m(0)}),[function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("div",{staticClass:"content"},[t("blockquote",[t("p",[v._v("Google(chrome) 对 URL 的长度限制为8182字节。")]),v._v(" "),t("p",[v._v("Safari(Browser)对URL的长度限制为80000字节。")]),v._v(" "),t("p",[v._v("Firefox(Browser)对URL的长度限制为65536字节。")])]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("请求资源过程")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("浏览器构造请求")]),v._v(" "),t("p",[v._v("浏览器会构建请求行:")]),v._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 请求方法是GET，路径为根路径，HTTP协议版本为1.1")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[v._v("GET")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[v._v("HTTP")]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("1.1")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br")])])]),v._v(" "),t("li",[t("p",[v._v("查找强缓存，如果命中则直接跳到解码阶段")])]),v._v(" "),t("li",[t("p",[v._v("DNS 解析")])]),v._v(" "),t("li",[t("p",[v._v("打开一个 socket 与目标 IP 地址、端口建立 TCP 链接（三次握手）")])]),v._v(" "),t("li",[t("p",[v._v("TSL 握手建立安全信道")])]),v._v(" "),t("li",[t("p",[v._v("服务器接受请求并解析，协商请求判断是返回 304 还是重新传输实体")])]),v._v(" "),t("li",[t("p",[v._v("服务器将响应报文通过 TCP 传输给浏览器")])]),v._v(" "),t("li",[t("p",[v._v("浏览器接收 HTTP 响应，响应状态码")]),v._v(" "),t("blockquote",[t("p",[v._v("如果地址栏输入的是 "),t("code",[v._v("meituan.com")]),v._v("，服务端会返回一个 301 （永久重定向）的响应，表示重定向到 "),t("code",[v._v("www.meituan.com")]),v._v("。")])])]),v._v(" "),t("li",[t("p",[v._v("关闭 TCP 链接 或者 保持长连接")])]),v._v(" "),t("li",[t("p",[v._v("根据 "),t("code",[v._v("Content-Encoding")]),v._v(" 对资源进行解码")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("浏览器解析和渲染过程")])]),v._v(" "),t("p",[v._v("先简单介绍一下 "),t("strong",[v._v("Chromium")]),v._v(" （Chromium 的内核则是渲染引擎 Blink（基于 Webkit）和 JavaScript 引擎 V8）的"),t("strong",[v._v("多进程多线程架构")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B.jpg",alt:""}})]),v._v(" "),t("ul",[t("li",[v._v("一个 Browser 进程")]),v._v(" "),t("li",[v._v("多个 Renderer 进程")]),v._v(" "),t("li",[v._v("一个 GPU 进程")]),v._v(" "),t("li",[v._v("多个 Plugin 进程")])]),v._v(" "),t("p",[v._v("每个进程有多个线程")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("一个主线程")]),v._v(" "),t("p",[v._v("Browser 进程中：用于渲染更新页面")]),v._v(" "),t("p",[v._v("Renderer 进程中：使用持有的内核 Blink 实例"),t("strong",[v._v("解析渲染更新")]),v._v("页面 ，按我现在的理解是 GUI 线程")])]),v._v(" "),t("li",[t("p",[v._v("一个 I/O 线程")]),v._v(" "),t("p",[v._v("Browser 进程中：处理 IPC 和网络请求")]),v._v(" "),t("p",[v._v("Renderer 进程中：处理与 Browser 进程之间的 IPC")])]),v._v(" "),t("li",[t("p",[v._v("一组专用线程")])]),v._v(" "),t("li",[t("p",[v._v("一个通用线程池")])])]),v._v(" "),t("p",[t("strong",[v._v("解析流程：")])]),v._v(" "),t("p",[v._v("页面解析过程是在 Renderer 进程中进行，Renderer 进程通过主线程中的 Blink 实例边读取边解析 HTML 文档，每次从网络缓冲区读取 8KB 以内的数据。解析 HTML 构建 DOM 树，当遇到 CSS 外链调用网络请求模块异步请求资源，不阻塞 DOM 树的构建。CSS 下载完毕后在合适的时机在主线程计算样式（格式化（"),t("code",[v._v("document.stylesheets")]),v._v("）和标准化**（目的是标准化一些 CSS 样式值便于 Webkit 理解，如 "),t("code",[v._v("white -> #ffffff、em -> px、bold -> 700")]),t("strong",[v._v("）），之后计算每个节点具体的样式，计算规则为")]),v._v("层叠和继承**。之后遍历 DOM 树并且运用 CSS 样式生成布局树。")]),v._v(" "),t("p",[t("strong",[v._v("渲染流程：")])]),v._v(" "),t("p",[v._v("生成布局树之后，还不能绘制页面。分层构建层树，生成绘制列表，渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。")]),v._v(" "),t("p",[v._v("​")]),v._v(" "),t("blockquote",[t("p",[v._v("计算样式和布局有个细节：")])]),v._v(" "),t("blockquote",[t("p",[v._v("通过层叠样式表每个 DOM 的指定值之后，浏览器首先会处理 inherit 和 initial 两个特殊值，然后计算，一般要计算的都是一些相对值（em、rem、百分比），转成绝对值，但 Style 之一阶段并不是所有属性的相对值都能够计算成绝对值，一些与布局相关的属性，比如 width、height、margin-right、text-align、top 等，如果它们使用百分比且参照元素的值也不是绝对值的时候，需要在下一步 Layout 确定之后才能转化为绝对值。")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B.png",alt:""}})]),v._v(" "),t("p",[v._v("一旦创建了层树并且确定了绘制顺序，主线程将信息提交（"),t("code",[v._v("Commit")]),v._v("）给 Compositor 线程（合成线程）。由合成器线程开启光栅化线程，栅格化每个层，一个图层可能像整个页面那么大，因此合成器线程会先将图层（合成层）分成"),t("code",[v._v("图块")]),v._v("（"),t("code",[v._v("titles")]),v._v("），之后再在"),t("code",[v._v("光栅化线程池")]),v._v("中将图块转换成位图，位图会作为纹理上传至 GPU 的内存中存储。最终由 GPU 合成展示页面。")])])]),v._v(" "),t("p",[v._v("​\t\t 再理解一下光栅化：")]),v._v(" "),t("pre",[t("code",[v._v("   浏览器知道文档的结构，每个元素的样式，页面的几何形状和绘制顺序，需将信息转换为屏幕\t\t 上的像素，称为光栅化。\n\n\t 栅格化：\n")])]),v._v(" "),t("p",[v._v("​\t\t  "),t("strong",[v._v("合成器线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行\t\t  的，将图块转换为位图")]),v._v("。")]),v._v(" "),t("p",[v._v("​\t\t"),t("img",{attrs:{src:"https://zhuzhu-chou.github.io/images/%E6%A0%85%E6%A0%BC%E5%8C%96.png",alt:""}})])])}],!1,null,null,null);_.default=s.exports}}]);